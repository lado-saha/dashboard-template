Project Context From: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms
Generated On: Fri Jun 20 03:24:44 PM WAT 2025
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target venv svgs fontawesome scss fonts webfonts images storage
Ignored File Patterns: *.log *.jar *.pdf *.png *.jpg *.class *.sqlite *.csv project_context.txt package-lock.json yarn.lock *.json composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms/contact-form.tsx

"use client";

import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { CreateContactRequest, UpdateContactRequest, ContactDto } from "@/types/organization";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";

const contactFormSchema = z.object({
  first_name: z.string().min(2, "First name is required."),
  last_name: z.string().min(2, "Last name is required."),
  title: z.string().optional().or(z.literal("")),
  email: z.string().email("Invalid email address.").optional().or(z.literal("")),
  phone_number: z.string().optional().or(z.literal("")),
  secondary_email: z.string().email("Invalid secondary email.").optional().or(z.literal("")),
  secondary_phone_number: z.string().optional().or(z.literal("")),
  fax_number: z.string().optional().or(z.literal("")),
});

type ContactFormData = z.infer<typeof contactFormSchema>;

interface ContactFormProps {
  initialData?: Partial<ContactDto>;
  mode: "create" | "edit";
  onSubmitAction: (data: ContactFormData) => Promise<void>;
  onCancelAction: () => void;
}

export function ContactForm({ initialData, mode, onSubmitAction, onCancelAction }: ContactFormProps) {
  const [isLoading, setIsLoading] = useState(false);

  const form = useForm<ContactFormData>({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      first_name: initialData?.first_name || "", last_name: initialData?.last_name || "",
      title: initialData?.title || "", email: initialData?.email || "", phone_number: initialData?.phone_number || "",
      secondary_email: initialData?.secondary_email || "", secondary_phone_number: initialData?.secondary_phone_number || "",
      fax_number: initialData?.fax_number || "",
    },
  });

  const handleSubmit = async (data: ContactFormData) => {
    setIsLoading(true);
    try {
      await onSubmitAction(data);
    } catch (error: any) {
      toast.error(error.message || `Failed to ${mode} contact.`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <FormField control={form.control} name="first_name" render={({ field }) => ( <FormItem><FormLabel>First Name *</FormLabel><FormControl><Input {...field} /></FormControl><FormMessage /></FormItem> )} />
          <FormField control={form.control} name="last_name" render={({ field }) => ( <FormItem><FormLabel>Last Name *</FormLabel><FormControl><Input {...field} /></FormControl><FormMessage /></FormItem> )} />
        </div>
        <FormField control={form.control} name="title" render={({ field }) => ( <FormItem><FormLabel>Title/Position</FormLabel><FormControl><Input {...field} /></FormControl><FormMessage /></FormItem> )} />
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <FormField control={form.control} name="email" render={({ field }) => ( <FormItem><FormLabel>Primary Email</FormLabel><FormControl><Input type="email" {...field} /></FormControl><FormMessage /></FormItem> )} />
          <FormField control={form.control} name="phone_number" render={({ field }) => ( <FormItem><FormLabel>Primary Phone</FormLabel><FormControl><Input type="tel" {...field} /></FormControl><FormMessage /></FormItem> )} />
        </div>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <FormField control={form.control} name="secondary_email" render={({ field }) => ( <FormItem><FormLabel>Secondary Email</FormLabel><FormControl><Input type="email" {...field} /></FormControl><FormMessage /></FormItem> )} />
          <FormField control={form.control} name="secondary_phone_number" render={({ field }) => ( <FormItem><FormLabel>Secondary Phone</FormLabel><FormControl><Input type="tel" {...field} /></FormControl><FormMessage /></FormItem> )} />
        </div>
        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onCancelAction} disabled={isLoading}>Cancel</Button>
          <Button type="submit" disabled={isLoading}>{isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />} {mode === "create" ? "Add Contact" : "Save Changes"}</Button>
        </div>
      </form>
    </Form>
  );
}// END OF FILE: contact-form.tsx

//---> PATH: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms/org-address-form.tsx

"use client";

import React, { useState, useEffect } from "react";
import * as z from "zod";
import { useDebounce } from "use-debounce";
import { LatLngExpression } from "leaflet";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { MapView } from "@/components/map/map-view";
import { mapRepository } from "@/lib/data-repo/map";
import { toast } from "sonner";
import { Loader2, Search } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

export const addressSchema = z.object({
  address_line_1: z.string().min(3, "Address line 1 is required."),
  address_line_2: z.string().optional().or(z.literal("")),
  city: z.string().min(2, "City is required."),
  state: z.string().min(2, "State/Province is required."),
  zip_code: z.string().min(3, "Zip/Postal code is required."),
  country: z.string().min(2, "Country is required."),
  latitude: z.coerce
    .number()
    .min(-90, "Invalid Latitude")
    .max(90, "Invalid Latitude")
    .optional(),
  longitude: z.coerce
    .number()
    .min(-180, "Invalid Longitude")
    .max(180, "Invalid Longitude")
    .optional(),
});

export type AddressFormData = z.infer<typeof addressSchema>;

interface OrgAddressFormProps {
  form: any;
  title?: string;
  description?: string;
}

const DEFAULT_CENTER: LatLngExpression = [51.505, -0.09];
const DEFAULT_ZOOM = 4;

export function OrgAddressForm({
  form,
  title = "Headquarters Address",
  description = "Provide the primary address. Click the map or enter coordinates to pinpoint the location.",
}: OrgAddressFormProps) {
  const [markerPosition, setMarkerPosition] = useState<LatLngExpression | null>(
    null
  );
  const [mapCenter, setMapCenter] = useState<LatLngExpression>(DEFAULT_CENTER);
  const [mapZoom, setMapZoom] = useState(DEFAULT_ZOOM);
  const [isGeocoding, setIsGeocoding] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  const { watch, getValues, setValue } = form;

  // REFINED LOGIC: Separate watch for coordinates to drive the map marker directly.
  const watchedCoords = watch(["latitude", "longitude"]);

  // Effect to initialize or update map from coordinate fields
  useEffect(() => {
    const [lat, lon] = watchedCoords;
    if (typeof lat === "number" && typeof lon === "number") {
      const newPos: LatLngExpression = [lat, lon];
      // Check if marker needs updating to avoid unnecessary re-renders
      const currentMarker = markerPosition as [number, number] | null;
      if (currentMarker?.[0] !== lat || currentMarker?.[1] !== lon) {
        setMarkerPosition(newPos);
        setMapCenter(newPos);
        setMapZoom(16);
      }
    }
  }, [watchedCoords, markerPosition]); // Reruns when lat/lon fields change

  const handleLocationSelectAction = async (lat: number, lng: number) => {
    setIsGeocoding(true);
    toast.loading("Fetching address from coordinates...");
    try {
      setValue("latitude", parseFloat(lat.toFixed(6)), {
        shouldValidate: true,
      });
      setValue("longitude", parseFloat(lng.toFixed(6)), {
        shouldValidate: true,
      });
      // The useEffect above will handle setting the marker position

      const data = await mapRepository.reverseGeocode(lat, lng);
      if (data?.address) {
        const addressLine1 = [data.address.house_number, data.address.road]
          .filter(Boolean)
          .join(" ");
        setValue("address_line_1", addressLine1, { shouldValidate: true });
        setValue("city", data.address.city || data.address.municipality || "", {
          shouldValidate: true,
        });
        setValue(
          "state",
          data.address.state || data.address.state_district || "",
          { shouldValidate: true }
        );
        setValue("zip_code", data.address.postcode || "", {
          shouldValidate: true,
        });
        setValue("country", data.address.country || "", {
          shouldValidate: true,
        });
        toast.success("Address updated from map!");
      } else {
        toast.warning("Could not find a specific address for this location.");
      }
    } catch (error) {
      toast.error("Failed to fetch address.");
    } finally {
      setIsGeocoding(false);
      toast.dismiss();
    }
  };

  // This logic for searching based on address text remains separate and tied to the search button.
  const handleSearchAddressAction = async () => {
    const addressParts = [
      getValues("address_line_1"),
      getValues("city"),
      getValues("state"),
      getValues("country"),
    ];
    const fullAddress = addressParts.filter(Boolean).join(", ");
    if (fullAddress.length < 5) {
      toast.info("Please enter an address to search.");
      return;
    }

    setIsGeocoding(true);
    toast.loading("Searching for address...");
    try {
      const results = await mapRepository.geocodeAddress(fullAddress);
      if (results && results.length > 0) {
        const { lat, lon } = results[0];
        setValue("latitude", parseFloat(lat), { shouldValidate: true });
        setValue("longitude", parseFloat(lon), { shouldValidate: true });
        toast.success("Address found on map!");
      } else {
        toast.warning("Could not find this address.");
      }
    } catch (error) {
      toast.error("Failed to search address.");
    } finally {
      toast.dismiss();
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
        <CardDescription>{description}</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div className="space-y-4">
            <div className="flex items-end gap-2">
              <FormField
                name="address_line_1"
                control={form.control}
                render={({ field }) => (
                  <FormItem className="flex-grow">
                    <FormLabel>Address Line 1 *</FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        placeholder="e.g., 1600 Amphitheatre Pkwy"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button
                type="button"
                variant="outline"
                size="icon"
                onClick={handleSearchAddressAction}
                disabled={isGeocoding}
                title="Search Address on Map"
              >
                <Search className="h-4 w-4" />
              </Button>
            </div>
            <FormField
              name="address_line_2"
              control={form.control}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Address Line 2</FormLabel>
                  <FormControl>
                    <Input {...field} placeholder="e.g., Suite 100" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <div className="grid grid-cols-2 gap-4">
              <FormField
                name="city"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>City *</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                name="state"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>State/Province *</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <div className="grid grid-cols-2 gap-4">
              <FormField
                name="zip_code"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Zip/Postal Code *</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                name="country"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Country *</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <div className="grid grid-cols-2 gap-4 pt-2">
              <FormField
                name="latitude"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Latitude</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="any"
                        {...field}
                        value={field.value ?? ""}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                name="longitude"
                control={form.control}
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Longitude</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="any"
                        {...field}
                        value={field.value ?? ""}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
          </div>
          <div
            className={cn(
              "relative rounded-md overflow-hidden min-h-[400px] transition-all duration-300",
              isFullscreen && "fixed inset-0 z-50"
            )}
          >
            {isGeocoding && !isFullscreen && (
              <div className="absolute inset-0 bg-background/50 z-20 flex items-center justify-center">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            )}
            <MapView
              center={mapCenter}
              zoom={mapZoom}
              markers={
                markerPosition
                  ? [{ id: "selected", position: markerPosition }]
                  : []
              }
              onLocationSelectAction={handleLocationSelectAction}
              isLocationPicker={true}
              className="h-full w-full"
              isFullscreen={isFullscreen}
              onToggleFullscreenAction={() => setIsFullscreen(!isFullscreen)}
            />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
// END OF FILE: org-address-form.tsx

//---> PATH: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms/org-basic-info-form.tsx

"use client";

import * as z from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { BusinessDomainDto } from "@/types/organization";

export const basicInfoSchema = z.object({
  long_name: z.string().min(3, "Official name is required.").max(100),
  short_name: z.string().min(2, "Short name is required.").max(50),
  ceo_name: z.string().min(3, "CEO's name is required.").max(50),
  email: z.string().email("A valid contact email is required."),
  description: z
    .string()
    .min(10, "Description must be at least 10 characters.")
    .max(500),
});

export type BasicInfoFormData = z.infer<typeof basicInfoSchema>;

interface BasicInfoFormProps {
  form: any;
  filteredDomains: BusinessDomainDto[];
  domainSearch: string;
  onDomainSearchChangeAction: (value: string) => void;
}

export function OrgBasicInfoForm({
  form,
  filteredDomains,
  domainSearch,
  onDomainSearchChangeAction,
}: BasicInfoFormProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Basic Info</CardTitle>
        <CardDescription>
          Enter the core details of your organization.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            name="long_name"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Official Name *</FormLabel>
                <FormControl>
                  <Input {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            name="short_name"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Short Name / Acronym *</FormLabel>
                <FormControl>
                  <Input {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            name="email"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Contact Email *</FormLabel>
                <FormControl>
                  <Input type="email" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            name="ceo_name"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>CEO's Name *</FormLabel>
                <FormControl>
                  <Input {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>
        <FormField
          name="description"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description *</FormLabel>
              <FormControl>
                <Textarea rows={4} {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="business_domains"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Business Domains *</FormLabel>
              <div className="border rounded-md p-2">
                <Input
                  placeholder="Search domains..."
                  className="mb-2 h-9"
                  value={domainSearch}
                  onChange={(e) => onDomainSearchChangeAction(e.target.value)}
                />
                <ScrollArea className="h-40">
                  <div className="space-y-2 p-1">
                    {filteredDomains.map((domain) => (
                      <FormItem
                        key={domain.id}
                        className="flex flex-row items-center space-x-3 space-y-0"
                      >
                        <FormControl>
                          <input
                            type="checkbox"
                            checked={field.value?.includes(domain.id!)}
                            onChange={(e) => {
                              const currentValues = field.value || [];
                              field.onChange(
                                e.target.checked
                                  ? [...currentValues, domain.id!]
                                  : currentValues.filter(
                                      (value: string) => value !== domain.id!
                                    )
                              );
                            }}
                            className="form-checkbox h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
                          />
                        </FormControl>
                        <FormLabel className="font-normal text-sm cursor-pointer">
                          {domain.name}
                        </FormLabel>
                      </FormItem>
                    ))}
                  </div>
                </ScrollArea>
              </div>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}
// END OF FILE: org-basic-info-form.tsx

//---> PATH: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms/org-branding-form.tsx

"use client";

import { useFieldArray } from "react-hook-form";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { ImageUploader } from "@/components/ui/image-uploader";
import { Link as LinkIcon, Trash2, PlusCircle } from "lucide-react";

export const brandingSchema = z.object({
  logo_url: z.string().url("Invalid URL.").optional().or(z.literal("")),
  web_site_url: z
    .string()
    .url("Invalid website URL.")
    .optional()
    .or(z.literal("")),
  social_networks: z
    .array(
      z.object({
        url: z
          .string()
          .url({ message: "Please enter a valid URL." })
          .or(z.literal("")),
      })
    )
    .optional(),
  keywords: z.string().optional().or(z.literal("")),
  ceo_name: z.string().optional().or(z.literal("")),
  number_of_employees: z.coerce
    .number()
    .int()
    .min(0, "Number of employees cannot be negative.")
    .optional()
    .nullable(),
});

export type BrandingFormData = z.infer<typeof brandingSchema>;

interface BrandingFormProps {
  form: any;
}

export function OrgBrandingForm({ form }: BrandingFormProps) {
  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: "social_networks",
  });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Branding & Details</CardTitle>
        <CardDescription>
          Add your logo, web presence, and other operational details.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          name="logo_url"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Logo</FormLabel>
              <FormControl>
                <ImageUploader
                  currentImageUrl={field.value}
                  onImageSelectedAction={(file, url) => field.onChange(url)}
                  label=""
                  aspectRatio="square"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="web_site_url"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Website URL</FormLabel>
              <FormControl>
                <Input type="url" {...field} value={field.value || ""} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="space-y-3">
          <FormLabel>Social Media Links</FormLabel>
          {fields.map((field, index) => (
            <FormField
              key={field.id}
              control={form.control}
              name={`social_networks.${index}.url`}
              render={({ field }) => (
                <FormItem>
                  <div className="flex items-center gap-2">
                    <LinkIcon className="h-4 w-4 text-muted-foreground" />
                    <FormControl>
                      <Input
                        placeholder="https://facebook.com/your-page"
                        {...field}
                      />
                    </FormControl>
                    {fields.length > 1 && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        onClick={() => remove(index)}
                        className="text-destructive hover:text-destructive h-9 w-9 flex-shrink-0"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />
          ))}
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => append({ url: "" })}
          >
            <PlusCircle className="mr-2 h-4 w-4" /> Add Social Link
          </Button>
        </div>

        <FormField
          name="keywords"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Keywords</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormDescription>
                Comma-separated values (e.g., tech, saas).
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}
// END OF FILE: org-branding-form.tsx

//---> PATH: /home/sih/Documents/GI/l4_s2/networks/projects/dashboard-template/components/organization/forms/org-legal-form.tsx

"use client";

import * as z from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { OrganizationLegalForm } from "@/types/organization";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { CalendarDays } from "lucide-react";

export const legalFormSchema = z.object({
  legal_form: z.string().min(1, "Legal form is required."),
  business_registration_number: z.string().optional().or(z.literal("")),
  tax_number: z.string().optional().or(z.literal("")),
  capital_share: z.coerce
    .number()
    .positive("Capital share must be positive.")
    .optional()
    .nullable(),
  registration_date: z.date().optional().nullable(),
  year_founded: z.date().optional().nullable(),
});

export type LegalFormData = z.infer<typeof legalFormSchema>;

const legalFormOptions: { value: OrganizationLegalForm; label: string }[] = [
  { value: "11", label: "Sole Proprietorship" },
  { value: "31", label: "Private Limited Company (Ltd)" },
  { value: "32", label: "Public Limited Company (PLC)" },
  { value: "51", label: "Cooperative" },
];

interface LegalFormProps {
  form: any;
}

export function OrgLegalForm({ form }: LegalFormProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Legal & Financial</CardTitle>
        <CardDescription>
          Provide the legal and financial details for your entity.
        </CardDescription>
      </CardHeader>
      <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          name="legal_form"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Legal Form *</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select..." />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {legalFormOptions.map((opt) => (
                    <SelectItem key={opt.value} value={opt.value}>
                      {opt.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="business_registration_number"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Business Registration No.</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="tax_number"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Tax ID / VAT Number</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="capital_share"
          control={form.control}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Capital Share (USD)</FormLabel>
              <FormControl>
                <Input type="number" {...field} value={field.value ?? ""} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="registration_date"
          control={form.control}
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Registration Date</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "h-10 w-full justify-start font-normal",
                        !field.value && "text-muted-foreground"
                      )}
                    >
                      <CalendarDays className="mr-2 h-4 w-4" />
                      {field.value ? (
                        format(field.value, "PPP")
                      ) : (
                        <span>Pick a date</span>
                      )}
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={field.value || undefined}
                    onSelect={field.onChange}
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          name="year_founded"
          control={form.control}
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Year Founded</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "h-10 w-full justify-start font-normal",
                        !field.value && "text-muted-foreground"
                      )}
                    >
                      <CalendarDays className="mr-2 h-4 w-4" />
                      {field.value ? (
                        format(field.value, "yyyy")
                      ) : (
                        <span>Pick year</span>
                      )}
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={field.value || undefined}
                    onSelect={field.onChange}
                    captionLayout="dropdown-buttons"
                    fromYear={1900}
                    toYear={new Date().getFullYear()}
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}
// END OF FILE: org-legal-form.tsx


Organization Creation Page

"use client";

import React, { useState, useEffect, useMemo, useCallback } from "react";
import { useRouter } from "next/navigation";
import {
  useForm,
  SubmitHandler,
  FieldErrors,
  FieldName,
} from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

import {
  CreateOrganizationRequest,
  UpdateOrganizationRequest,
  OrganizationDto,
  BusinessDomainDto,
  OrganizationLegalForm,
  CreateAddressRequest,
  AddressDto,
} from "@/types/organization";
import { organizationRepository } from "@/lib/data-repo/organization";
import { toast } from "sonner";

import { CardFooter } from "@/components/ui/card";
import { Form } from "@/components/ui/form";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Loader2, Info, FileText, Building, MapPin } from "lucide-react";

import { OrgBasicInfoForm, basicInfoSchema } from "./forms/org-basic-info-form";
import { OrgLegalForm, legalFormSchema } from "./forms/org-legal-form";
import { OrgBrandingForm, brandingSchema } from "./forms/org-branding-form";
import { OrgAddressForm, addressSchema } from "./forms/org-address-form";
import { isValid, parseISO } from "date-fns";

const fullOrganizationSchema = basicInfoSchema
  .merge(legalFormSchema)
  .merge(brandingSchema)
  .merge(addressSchema)
  .extend({
    business_domains: z
      .array(z.string())
      .min(1, "At least one business domain is required."),
  });

type OrganizationFormData = z.infer<typeof fullOrganizationSchema>;

interface OrganizationFormProps {
  initialData?: Partial<OrganizationDto>;
  mode: "create" | "edit";
  onFormSubmitSuccessAction: (data: OrganizationDto) => void;
  organizationId?: string;
  defaultAddress?: AddressDto | null;
}

const formSteps = [
  {
    id: "step1",
    name: "Basic Info",
    icon: Info,
    fields: Object.keys(
      basicInfoSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step2",
    name: "Legal & Financial",
    icon: FileText,
    fields: Object.keys(
      legalFormSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step3",
    name: "Branding & Details",
    icon: Building,
    fields: Object.keys(
      brandingSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step4",
    name: "Headquarters",
    icon: MapPin,
    fields: Object.keys(
      addressSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
];

export function OrganizationForm({
  initialData,
  mode,
  onFormSubmitSuccessAction,
  organizationId,
  defaultAddress, // THE FIX: Destructure new prop
}: OrganizationFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [availableBusinessDomains, setAvailableBusinessDomains] = useState<
    BusinessDomainDto[]
  >([]);
  const [domainSearch, setDomainSearch] = useState("");

  const form = useForm<OrganizationFormData>({
    resolver: zodResolver(fullOrganizationSchema),
    mode: "onChange",
    defaultValues: {
      long_name: initialData?.long_name || "",
      short_name: initialData?.short_name || "",
      email: initialData?.email || "",
      description: initialData?.description || "",
      business_domains: initialData?.business_domains || [],
      legal_form: initialData?.legal_form || "",
      business_registration_number:
        initialData?.business_registration_number || "",
      tax_number: initialData?.tax_number || "",
      capital_share: initialData?.capital_share || null,
      registration_date:
        initialData?.registration_date &&
        isValid(new Date(initialData.registration_date))
          ? new Date(initialData.registration_date)
          : undefined,
      year_founded:
        initialData?.year_founded && isValid(new Date(initialData.year_founded))
          ? new Date(
              new Date(initialData.year_founded).getFullYear().toString()
            )
          : undefined,
      logo_url: initialData?.logo_url || "",
      web_site_url: initialData?.website_url || "",
      social_networks: initialData?.social_network
        ? initialData.social_network
            .split(",")
            .filter(Boolean)
            .map((url) => ({ url }))
        : [{ url: "" }],
      keywords: Array.isArray(initialData?.keywords)
        ? initialData.keywords.join(", ")
        : initialData?.keywords || "",
      ceo_name: initialData?.ceo_name || "",
      number_of_employees: (initialData as any)?.number_of_employees || null,
      address_line_1: "",
      address_line_2: "",
      city: "",
      state: "",
      zip_code: "",
      country: "",
      latitude: undefined,
      longitude: undefined,
    },
  });

  useEffect(() => {
    organizationRepository
      .getAllBusinessDomains()
      .then(setAvailableBusinessDomains);
  }, []);

  useEffect(() => {
    if (initialData) {
      const combinedData = {
        ...initialData,
        keywords: Array.isArray(initialData.keywords)
          ? initialData.keywords.join(", ")
          : initialData.keywords || "",
        social_networks: initialData.social_network
          ? initialData.social_network
              .split(",")
              .filter(Boolean)
              .map((url) => ({ url }))
          : [{ url: "" }],
        registration_date:
          initialData.registration_date &&
          isValid(new Date(initialData.registration_date))
            ? new Date(initialData.registration_date)
            : undefined,
        year_founded:
          initialData.year_founded &&
          isValid(new Date(initialData.year_founded))
            ? new Date(initialData.year_founded)
            : undefined,
        // Now, merge the default address if it exists
        address_line_1: defaultAddress?.address_line_1 || "",
        address_line_2: defaultAddress?.address_line_2 || "",
        city: defaultAddress?.city || "",
        state: defaultAddress?.state || "",
        zip_code: defaultAddress?.zip_code || "",
        country: defaultAddress?.country_id || "", // Map country_id to country field
        latitude: defaultAddress?.latitude,
        longitude: defaultAddress?.longitude,
      };
      form.reset(combinedData);
    }
  }, [initialData, defaultAddress, form]);

  const handleHashChange = useCallback(() => {
    if (mode === "edit") {
      const hash = window.location.hash.replace("#", "");
      const stepIndex = formSteps.findIndex((step) => step.id === hash);
      if (stepIndex !== -1 && stepIndex !== currentStep)
        setCurrentStep(stepIndex);
    }
  }, [mode, currentStep]);

  useEffect(() => {
    /* ... same effect for hash change ... */
    window.addEventListener("hashchange", handleHashChange);
    handleHashChange();
    return () => window.removeEventListener("hashchange", handleHashChange);
  }, [handleHashChange]);

  const filteredDomains = useMemo(() => {
    /* ... same memoized filtering ... */
    if (!domainSearch) return availableBusinessDomains;
    return availableBusinessDomains.filter((domain) =>
      domain.name?.toLowerCase().includes(domainSearch.toLowerCase())
    );
  }, [domainSearch, availableBusinessDomains]);

  const handleNextStep = async () => {
    /* ... same next step logic ... */
    const fieldsToValidate = formSteps[currentStep].fields;
    const isStepValid = await form.trigger(
      fieldsToValidate as (keyof OrganizationFormData)[]
    );

    let isDomainValid = true;
    if (currentStep === 0) {
      if (form.getValues("business_domains").length === 0) {
        form.setError("business_domains", {
          type: "manual",
          message: "At least one business domain is required.",
        });
        isDomainValid = false;
      } else {
        form.clearErrors("business_domains");
      }
    }
    if (isStepValid && isDomainValid) {
      if (currentStep < formSteps.length - 1) {
        const nextStepId = formSteps[currentStep + 1].id;
        setCurrentStep((p) => p + 1);
        if (mode === "edit")
          router.replace(`#${nextStepId}`, { scroll: false });
      }
    } else {
      toast.error("Please fix the errors on this page before proceeding.");
    }
  };

  const handleTabChange = (value: string) => {
    const targetStepIndex = formSteps.findIndex((s) => s.id === value);
    if (targetStepIndex === -1) return;
    if (mode === "create" && targetStepIndex > currentStep) {
      toast.info("Please use the 'Next' button to proceed sequentially.");
      return;
    }
    setCurrentStep(targetStepIndex);
    if (mode === "edit") router.replace(`#${value}`, { scroll: false });
  };

  const onInvalidSubmit = (errors: FieldErrors<OrganizationFormData>) => {
    toast.error("Please fix the errors before submitting.");
    for (const [index, step] of formSteps.entries()) {
      const hasErrorInStep = step.fields.some(
        (field) => errors[field as keyof OrganizationFormData]
      );
      if (hasErrorInStep || (index === 0 && errors.business_domains)) {
        setCurrentStep(index);
        if (mode === "edit") router.replace(`#${step.id}`, { scroll: false });
        return;
      }
    }
  };

  // THE FIX: Corrected submission flow
  const processAndSubmit = async (data: OrganizationFormData) => {
    setIsLoading(true);

    const orgPayload: CreateOrganizationRequest = {
      long_name: data.long_name,
      short_name: data.short_name,
      email: data.email,
      description: data.description,
      legal_form: data.legal_form as OrganizationLegalForm,
      business_domains: data.business_domains,
      logo_url: data.logo_url,
      web_site_url: data.web_site_url,
      social_network:
        data.social_networks
          ?.map((item) => item.url)
          .filter(Boolean)
          .join(",") || "",
      keywords: data.keywords
        ? data.keywords
            .split(",")
            .map((k) => k.trim())
            .filter(Boolean)
        : [],
      business_registration_number: data.business_registration_number,
      tax_number: data.tax_number,
      capital_share:
        data.capital_share == null ? undefined : data.capital_share,
      registration_date: data.registration_date?.toISOString(),
      year_founded: data.year_founded?.toISOString(),
      ceo_name: data.ceo_name,
      number_of_employees:
        data.number_of_employees == null ? undefined : data.number_of_employees,
    };

    const addressPayload: CreateAddressRequest = {
      address_line_1: data.address_line_1,
      address_line_2: data.address_line_2,
      city: data.city,
      state: data.state,
      zip_code: data.zip_code,
      country_id: data.country,
      latitude: data.latitude,
      longitude: data.longitude,
    };

    try {
      if (mode === "create") {
        addressPayload.default = true;

        // Step 1: Create the organization
        const orgResponse = await organizationRepository.createOrganization(
          orgPayload
        );

        // Step 2: If org creation is successful, create its address
        if (orgResponse && orgResponse.organization_id) {
          try {
            await organizationRepository.createAddress(
              "ORGANIZATION",
              orgResponse.organization_id,
              addressPayload
            );
          } catch (addressError: any) {
            // Log address error but still proceed, as the org was created.
            toast.error(
              `Organization created, but failed to save address: ${addressError.message}`
            );
          }
        } else {
          throw new Error("Failed to get organization ID after creation.");
        }

        // Step 3: All steps successful, now call success action
        toast.success(
          `Organization "${orgResponse.short_name}" created successfully!`
        );
        onFormSubmitSuccessAction(orgResponse);
      } else {
        // Edit mode
        const orgUpdateResponse =
          await organizationRepository.updateOrganization(
            organizationId!,
            orgPayload as UpdateOrganizationRequest
          );
        // In edit mode, address handling is more complex (update existing or create new).
        // This is handled in the `profile` page for now. We can enhance this later if needed.
        toast.success(`Organization updated successfully!`);
        onFormSubmitSuccessAction(orgUpdateResponse);
      }
    } catch (error: any) {
      toast.error(error.message || `Failed to ${mode} organization.`);
    } finally {
      setIsLoading(false);
    }
  };

  const renderCurrentStep = () => {
    switch (currentStep) {
      case 0:
        return (
          <OrgBasicInfoForm
            form={form}
            filteredDomains={filteredDomains}
            domainSearch={domainSearch}
            onDomainSearchChangeAction={setDomainSearch}
          />
        );
      case 1:
        return <OrgLegalForm form={form} />;
      case 2:
        return <OrgBrandingForm form={form} />;
      case 3:
        return <OrgAddressForm form={form} />;
      default:
        return null;
    }
  };

  if (mode === "edit") {
    /* ... same edit mode return ... */
    return (
      <Form {...form}>
        <form
          onSubmit={form.handleSubmit(processAndSubmit, onInvalidSubmit)}
          className="space-y-6"
        >
          <OrgBasicInfoForm
            form={form}
            filteredDomains={filteredDomains}
            domainSearch={domainSearch}
            onDomainSearchChangeAction={setDomainSearch}
          />
          <OrgLegalForm form={form} />
          <OrgBrandingForm form={form} />
          <OrgAddressForm
            form={form}
            title="Primary Address"
            description="Update the main address for your organization."
          />
          <div className="flex justify-end">
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}{" "}
              Save All Changes
            </Button>
          </div>
        </form>
      </Form>
    );
  }

  return (
    /* ... same create mode wizard return ... */
    <Form {...form}>
      <div>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold">Create Organization</h2>
          <div className="text-sm font-medium text-muted-foreground">
            Step {currentStep + 1} of {formSteps.length}
          </div>
        </div>
        <Tabs
          value={formSteps[currentStep].id}
          onValueChange={handleTabChange}
          className="w-full"
        >
          <TabsList className="grid w-full grid-cols-4">
            {formSteps.map((step, index) => (
              <TabsTrigger
                key={step.id}
                value={step.id}
                disabled={index > currentStep}
              >
                <step.icon className="mr-2 h-4 w-4" />
                {step.name}
              </TabsTrigger>
            ))}
          </TabsList>
          <div className="mt-4 min-h-[400px]">{renderCurrentStep()}</div>
        </Tabs>
        <CardFooter className="flex justify-between mt-6 px-0">
          <Button
            type="button"
            variant="outline"
            onClick={() => setCurrentStep((p) => p - 1)}
            disabled={currentStep === 0}
          >
            Back
          </Button>
          {currentStep < formSteps.length - 1 ? (
            <Button type="button" onClick={handleNextStep}>
              Next
            </Button>
          ) : (
            <Button
              type="button"
              disabled={isLoading}
              onClick={form.handleSubmit(processAndSubmit, onInvalidSubmit)}
            >
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Finish & Create Organization
            </Button>
          )}
        </CardFooter>
      </div>
    </Form>
  );
}

Creation form 

"use client";

import React, { useState, useEffect, useMemo, useCallback } from "react";
import { useRouter } from "next/navigation";
import {
  useForm,
  SubmitHandler,
  FieldErrors,
  FieldName,
} from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

import {
  CreateOrganizationRequest,
  UpdateOrganizationRequest,
  OrganizationDto,
  BusinessDomainDto,
  OrganizationLegalForm,
  CreateAddressRequest,
  AddressDto,
} from "@/types/organization";
import { organizationRepository } from "@/lib/data-repo/organization";
import { toast } from "sonner";

import { CardFooter } from "@/components/ui/card";
import { Form } from "@/components/ui/form";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Loader2, Info, FileText, Building, MapPin } from "lucide-react";

import { OrgBasicInfoForm, basicInfoSchema } from "./forms/org-basic-info-form";
import { OrgLegalForm, legalFormSchema } from "./forms/org-legal-form";
import { OrgBrandingForm, brandingSchema } from "./forms/org-branding-form";
import { OrgAddressForm, addressSchema } from "./forms/org-address-form";
import { isValid, parseISO } from "date-fns";

const fullOrganizationSchema = basicInfoSchema
  .merge(legalFormSchema)
  .merge(brandingSchema)
  .merge(addressSchema)
  .extend({
    business_domains: z
      .array(z.string())
      .min(1, "At least one business domain is required."),
  });

type OrganizationFormData = z.infer<typeof fullOrganizationSchema>;

interface OrganizationFormProps {
  initialData?: Partial<OrganizationDto>;
  mode: "create" | "edit";
  onFormSubmitSuccessAction: (data: OrganizationDto) => void;
  organizationId?: string;
  defaultAddress?: AddressDto | null;
}

const formSteps = [
  {
    id: "step1",
    name: "Basic Info",
    icon: Info,
    fields: Object.keys(
      basicInfoSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step2",
    name: "Legal & Financial",
    icon: FileText,
    fields: Object.keys(
      legalFormSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step3",
    name: "Branding & Details",
    icon: Building,
    fields: Object.keys(
      brandingSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
  {
    id: "step4",
    name: "Headquarters",
    icon: MapPin,
    fields: Object.keys(
      addressSchema.shape
    ) as FieldName<OrganizationFormData>[],
  },
];

export function OrganizationForm({
  initialData,
  mode,
  onFormSubmitSuccessAction,
  organizationId,
  defaultAddress, // THE FIX: Destructure new prop
}: OrganizationFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [availableBusinessDomains, setAvailableBusinessDomains] = useState<
    BusinessDomainDto[]
  >([]);
  const [domainSearch, setDomainSearch] = useState("");

  const form = useForm<OrganizationFormData>({
    resolver: zodResolver(fullOrganizationSchema),
    mode: "onChange",
    defaultValues: {
      long_name: initialData?.long_name || "",
      short_name: initialData?.short_name || "",
      email: initialData?.email || "",
      description: initialData?.description || "",
      business_domains: initialData?.business_domains || [],
      legal_form: initialData?.legal_form || "",
      business_registration_number:
        initialData?.business_registration_number || "",
      tax_number: initialData?.tax_number || "",
      capital_share: initialData?.capital_share || null,
      registration_date:
        initialData?.registration_date &&
        isValid(new Date(initialData.registration_date))
          ? new Date(initialData.registration_date)
          : undefined,
      year_founded:
        initialData?.year_founded && isValid(new Date(initialData.year_founded))
          ? new Date(
              new Date(initialData.year_founded).getFullYear().toString()
            )
          : undefined,
      logo_url: initialData?.logo_url || "",
      web_site_url: initialData?.website_url || "",
      social_networks: initialData?.social_network
        ? initialData.social_network
            .split(",")
            .filter(Boolean)
            .map((url) => ({ url }))
        : [{ url: "" }],
      keywords: Array.isArray(initialData?.keywords)
        ? initialData.keywords.join(", ")
        : initialData?.keywords || "",
      ceo_name: initialData?.ceo_name || "",
      number_of_employees: (initialData as any)?.number_of_employees || null,
      address_line_1: "",
      address_line_2: "",
      city: "",
      state: "",
      zip_code: "",
      country: "",
      latitude: undefined,
      longitude: undefined,
    },
  });

  useEffect(() => {
    organizationRepository
      .getAllBusinessDomains()
      .then(setAvailableBusinessDomains);
  }, []);

  useEffect(() => {
    if (initialData) {
      const combinedData = {
        ...initialData,
        keywords: Array.isArray(initialData.keywords)
          ? initialData.keywords.join(", ")
          : initialData.keywords || "",
        social_networks: initialData.social_network
          ? initialData.social_network
              .split(",")
              .filter(Boolean)
              .map((url) => ({ url }))
          : [{ url: "" }],
        registration_date:
          initialData.registration_date &&
          isValid(new Date(initialData.registration_date))
            ? new Date(initialData.registration_date)
            : undefined,
        year_founded:
          initialData.year_founded &&
          isValid(new Date(initialData.year_founded))
            ? new Date(initialData.year_founded)
            : undefined,
        // Now, merge the default address if it exists
        address_line_1: defaultAddress?.address_line_1 || "",
        address_line_2: defaultAddress?.address_line_2 || "",
        city: defaultAddress?.city || "",
        state: defaultAddress?.state || "",
        zip_code: defaultAddress?.zip_code || "",
        country: defaultAddress?.country_id || "", // Map country_id to country field
        latitude: defaultAddress?.latitude,
        longitude: defaultAddress?.longitude,
      };
      form.reset(combinedData);
    }
  }, [initialData, defaultAddress, form]);

  const handleHashChange = useCallback(() => {
    if (mode === "edit") {
      const hash = window.location.hash.replace("#", "");
      const stepIndex = formSteps.findIndex((step) => step.id === hash);
      if (stepIndex !== -1 && stepIndex !== currentStep)
        setCurrentStep(stepIndex);
    }
  }, [mode, currentStep]);

  useEffect(() => {
    /* ... same effect for hash change ... */
    window.addEventListener("hashchange", handleHashChange);
    handleHashChange();
    return () => window.removeEventListener("hashchange", handleHashChange);
  }, [handleHashChange]);

  const filteredDomains = useMemo(() => {
    /* ... same memoized filtering ... */
    if (!domainSearch) return availableBusinessDomains;
    return availableBusinessDomains.filter((domain) =>
      domain.name?.toLowerCase().includes(domainSearch.toLowerCase())
    );
  }, [domainSearch, availableBusinessDomains]);

  const handleNextStep = async () => {
    /* ... same next step logic ... */
    const fieldsToValidate = formSteps[currentStep].fields;
    const isStepValid = await form.trigger(
      fieldsToValidate as (keyof OrganizationFormData)[]
    );

    let isDomainValid = true;
    if (currentStep === 0) {
      if (form.getValues("business_domains").length === 0) {
        form.setError("business_domains", {
          type: "manual",
          message: "At least one business domain is required.",
        });
        isDomainValid = false;
      } else {
        form.clearErrors("business_domains");
      }
    }
    if (isStepValid && isDomainValid) {
      if (currentStep < formSteps.length - 1) {
        const nextStepId = formSteps[currentStep + 1].id;
        setCurrentStep((p) => p + 1);
        if (mode === "edit")
          router.replace(`#${nextStepId}`, { scroll: false });
      }
    } else {
      toast.error("Please fix the errors on this page before proceeding.");
    }
  };

  const handleTabChange = (value: string) => {
    const targetStepIndex = formSteps.findIndex((s) => s.id === value);
    if (targetStepIndex === -1) return;
    if (mode === "create" && targetStepIndex > currentStep) {
      toast.info("Please use the 'Next' button to proceed sequentially.");
      return;
    }
    setCurrentStep(targetStepIndex);
    if (mode === "edit") router.replace(`#${value}`, { scroll: false });
  };

  const onInvalidSubmit = (errors: FieldErrors<OrganizationFormData>) => {
    toast.error("Please fix the errors before submitting.");
    for (const [index, step] of formSteps.entries()) {
      const hasErrorInStep = step.fields.some(
        (field) => errors[field as keyof OrganizationFormData]
      );
      if (hasErrorInStep || (index === 0 && errors.business_domains)) {
        setCurrentStep(index);
        if (mode === "edit") router.replace(`#${step.id}`, { scroll: false });
        return;
      }
    }
  };

  // THE FIX: Corrected submission flow
  const processAndSubmit = async (data: OrganizationFormData) => {
    setIsLoading(true);

    const orgPayload: CreateOrganizationRequest = {
      long_name: data.long_name,
      short_name: data.short_name,
      email: data.email,
      description: data.description,
      legal_form: data.legal_form as OrganizationLegalForm,
      business_domains: data.business_domains,
      logo_url: data.logo_url,
      web_site_url: data.web_site_url,
      social_network:
        data.social_networks
          ?.map((item) => item.url)
          .filter(Boolean)
          .join(",") || "",
      keywords: data.keywords
        ? data.keywords
            .split(",")
            .map((k) => k.trim())
            .filter(Boolean)
        : [],
      business_registration_number: data.business_registration_number,
      tax_number: data.tax_number,
      capital_share:
        data.capital_share == null ? undefined : data.capital_share,
      registration_date: data.registration_date?.toISOString(),
      year_founded: data.year_founded?.toISOString(),
      ceo_name: data.ceo_name,
      number_of_employees:
        data.number_of_employees == null ? undefined : data.number_of_employees,
    };

    const addressPayload: CreateAddressRequest = {
      address_line_1: data.address_line_1,
      address_line_2: data.address_line_2,
      city: data.city,
      state: data.state,
      zip_code: data.zip_code,
      country_id: data.country,
      latitude: data.latitude,
      longitude: data.longitude,
    };

    try {
      if (mode === "create") {
        addressPayload.default = true;

        // Step 1: Create the organization
        const orgResponse = await organizationRepository.createOrganization(
          orgPayload
        );

        // Step 2: If org creation is successful, create its address
        if (orgResponse && orgResponse.organization_id) {
          try {
            await organizationRepository.createAddress(
              "ORGANIZATION",
              orgResponse.organization_id,
              addressPayload
            );
          } catch (addressError: any) {
            // Log address error but still proceed, as the org was created.
            toast.error(
              `Organization created, but failed to save address: ${addressError.message}`
            );
          }
        } else {
          throw new Error("Failed to get organization ID after creation.");
        }

        // Step 3: All steps successful, now call success action
        toast.success(
          `Organization "${orgResponse.short_name}" created successfully!`
        );
        onFormSubmitSuccessAction(orgResponse);
      } else {
        // Edit mode
        const orgUpdateResponse =
          await organizationRepository.updateOrganization(
            organizationId!,
            orgPayload as UpdateOrganizationRequest
          );
        // In edit mode, address handling is more complex (update existing or create new).
        // This is handled in the `profile` page for now. We can enhance this later if needed.
        toast.success(`Organization updated successfully!`);
        onFormSubmitSuccessAction(orgUpdateResponse);
      }
    } catch (error: any) {
      toast.error(error.message || `Failed to ${mode} organization.`);
    } finally {
      setIsLoading(false);
    }
  };

  const renderCurrentStep = () => {
    switch (currentStep) {
      case 0:
        return (
          <OrgBasicInfoForm
            form={form}
            filteredDomains={filteredDomains}
            domainSearch={domainSearch}
            onDomainSearchChangeAction={setDomainSearch}
          />
        );
      case 1:
        return <OrgLegalForm form={form} />;
      case 2:
        return <OrgBrandingForm form={form} />;
      case 3:
        return <OrgAddressForm form={form} />;
      default:
        return null;
    }
  };

  if (mode === "edit") {
    /* ... same edit mode return ... */
    return (
      <Form {...form}>
        <form
          onSubmit={form.handleSubmit(processAndSubmit, onInvalidSubmit)}
          className="space-y-6"
        >
          <OrgBasicInfoForm
            form={form}
            filteredDomains={filteredDomains}
            domainSearch={domainSearch}
            onDomainSearchChangeAction={setDomainSearch}
          />
          <OrgLegalForm form={form} />
          <OrgBrandingForm form={form} />
          <OrgAddressForm
            form={form}
            title="Primary Address"
            description="Update the main address for your organization."
          />
          <div className="flex justify-end">
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}{" "}
              Save All Changes
            </Button>
          </div>
        </form>
      </Form>
    );
  }

  return (
    /* ... same create mode wizard return ... */
    <Form {...form}>
      <div>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold">Create Organization</h2>
          <div className="text-sm font-medium text-muted-foreground">
            Step {currentStep + 1} of {formSteps.length}
          </div>
        </div>
        <Tabs
          value={formSteps[currentStep].id}
          onValueChange={handleTabChange}
          className="w-full"
        >
          <TabsList className="grid w-full grid-cols-4">
            {formSteps.map((step, index) => (
              <TabsTrigger
                key={step.id}
                value={step.id}
                disabled={index > currentStep}
              >
                <step.icon className="mr-2 h-4 w-4" />
                {step.name}
              </TabsTrigger>
            ))}
          </TabsList>
          <div className="mt-4 min-h-[400px]">{renderCurrentStep()}</div>
        </Tabs>
        <CardFooter className="flex justify-between mt-6 px-0">
          <Button
            type="button"
            variant="outline"
            onClick={() => setCurrentStep((p) => p - 1)}
            disabled={currentStep === 0}
          >
            Back
          </Button>
          {currentStep < formSteps.length - 1 ? (
            <Button type="button" onClick={handleNextStep}>
              Next
            </Button>
          ) : (
            <Button
              type="button"
              disabled={isLoading}
              onClick={form.handleSubmit(processAndSubmit, onInvalidSubmit)}
            >
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Finish & Create Organization
            </Button>
          )}
        </CardFooter>
      </div>
    </Form>
  );
}
